#!/usr/bin/env python3
"""Generate TypeScript spec data from the reference pylatexenc implementation."""
from __future__ import annotations

import json
from pathlib import Path
from typing import Iterable

import sys

# Ensure local pylatexenc reference is importable
PROJECT_ROOT = Path(__file__).resolve().parents[1]
PYLATEXENC_ROOT = PROJECT_ROOT / "pylatexenc"
if str(PYLATEXENC_ROOT) not in sys.path:
    sys.path.insert(0, str(PYLATEXENC_ROOT))

from pylatexenc.latexwalker import _defaultspecs as lw_specs
from pylatexenc.latex2text import _defaultspecs as l2t_specs

OUTPUT_DIR = PROJECT_ROOT / "src" / "data"
OUTPUT_DIR.mkdir(parents=True, exist_ok=True)


def format_ts_array(name: str, entries: Iterable[dict]) -> str:
    lines = [f"export const {name} = ["]
    for entry in entries:
        json_repr = json.dumps(entry, ensure_ascii=False, sort_keys=True)
        lines.append(f"  {json_repr},")
    lines.append("] as const")
    return "\n".join(lines)


# ---------------- Parsing specs (LatexWalker) ----------------
macro_entries = []
for category, bucket in lw_specs.specs:
    for spec in bucket["macros"]:
        parser = getattr(spec, "args_parser", None)
        argspec = getattr(parser, "argspec", "") if parser else ""
        optional_no_space = bool(getattr(parser, "optional_arg_no_space", False)) if parser else False
        macro_entries.append({
            "name": spec.macroname,
            "argspec": argspec,
            "optionalArgNoSpace": optional_no_space,
        })

# Deduplicate while preserving order
seen = set()
unique_macro_entries = []
for entry in macro_entries:
    if entry["name"] in seen:
        continue
    seen.add(entry["name"])
    unique_macro_entries.append(entry)

environment_entries = []
seen_env = set()
for category, bucket in lw_specs.specs:
    for spec in bucket["environments"]:
        parser = getattr(spec, "args_parser", None)
        argspec = getattr(parser, "argspec", "") if parser else ""
        is_math = bool(getattr(spec, "is_math_mode", False))
        name = spec.environmentname
        if name in seen_env:
            continue
        seen_env.add(name)
        environment_entries.append({
            "name": name,
            "argspec": argspec,
            "isMathMode": is_math,
        })

special_entries = []
seen_spec = set()
for category, bucket in lw_specs.specs:
    for spec in bucket["specials"]:
        chars = spec.specials_chars
        if chars in seen_spec:
            continue
        seen_spec.add(chars)
        special_entries.append({"chars": chars})

parsing_ts = "\n\n".join([
    "// Auto-generated by tools/generate_specs.py -- do not edit manually.",
    "export interface GeneratedMacroParsingSpec {\n  name: string\n  argspec: string\n  optionalArgNoSpace: boolean\n}",
    "export interface GeneratedEnvironmentParsingSpec {\n  name: string\n  argspec: string\n  isMathMode: boolean\n}",
    "export interface GeneratedSpecialParsingSpec {\n  chars: string\n}",
    format_ts_array("generatedMacroParsingSpecs", unique_macro_entries),
    format_ts_array("generatedEnvironmentParsingSpecs", environment_entries),
    format_ts_array("generatedSpecialParsingSpecs", special_entries),
])

(OUTPUT_DIR / "generatedParsingSpec.ts").write_text(parsing_ts, encoding="utf-8")

# ---------------- Latex2Text default specs ----------------
def iter_latex2text_specs(kind: str):
    for _category, bucket in l2t_specs.specs:
        for spec in bucket[kind]:
            yield spec


string_macro_entries = []
none_macro_entries = []
function_macro_names: set[str] = set()
seen_macro_names: set[str] = set()
for spec in iter_latex2text_specs("macros"):
    name = spec.macroname
    if name in seen_macro_names:
        continue
    seen_macro_names.add(name)

    repl = spec.simplify_repl
    record = {
        "name": name,
        "discard": bool(spec.discard),
    }
    if repl is None:
        none_macro_entries.append(record)
    elif isinstance(repl, str):
        record["replacement"] = repl
        string_macro_entries.append(record)
    else:
        function_macro_names.add(name)

string_env_entries = []
function_env_names: set[str] = set()
seen_env_names: set[str] = set()
for spec in iter_latex2text_specs("environments"):
    name = spec.environmentname
    if name in seen_env_names:
        continue
    seen_env_names.add(name)

    repl = spec.simplify_repl
    record = {
        "name": name,
        "discard": bool(spec.discard),
    }
    if repl is None:
        string_env_entries.append(record)
    elif isinstance(repl, str):
        record["replacement"] = repl
        string_env_entries.append(record)
    else:
        function_env_names.add(name)

special_string_entries = []
seen_special_chars: set[str] = set()
for spec in iter_latex2text_specs("specials"):
    chars = spec.specials_chars
    if chars in seen_special_chars:
        continue
    seen_special_chars.add(chars)

    repl = spec.simplify_repl
    if isinstance(repl, str):
        special_string_entries.append({
            "chars": chars,
            "replacement": repl,
        })

text_ts = "\n\n".join([
    "// Auto-generated by tools/generate_specs.py -- do not edit manually.",
    "export interface GeneratedStringMacroTextSpec {\n  name: string\n  replacement: string\n  discard: boolean\n}",
    "export interface GeneratedNoneMacroTextSpec {\n  name: string\n  discard: boolean\n}",
    "export interface GeneratedStringEnvironmentTextSpec {\n  name: string\n  replacement?: string\n  discard: boolean\n}",
    "export interface GeneratedStringSpecialTextSpec {\n  chars: string\n  replacement: string\n}",
    format_ts_array("generatedStringMacroTextSpecs", string_macro_entries),
    format_ts_array("generatedNoneMacroTextSpecs", none_macro_entries),
    format_ts_array("generatedStringEnvironmentTextSpecs", string_env_entries),
    format_ts_array("generatedStringSpecialTextSpecs", special_string_entries),
    format_ts_array("generatedFunctionMacroNames", [ {"name": name} for name in sorted(function_macro_names) ]),
    format_ts_array("generatedFunctionEnvironmentNames", [ {"name": name} for name in sorted(function_env_names) ]),
])

(OUTPUT_DIR / "generatedTextSpecs.ts").write_text(text_ts, encoding="utf-8")

print("Generated parsing and text spec data under src/data/")
